let ground_INDUCT,ground_RECUR = define_type
  "ground = VAL A
          | VAPP ground ground";;

let GROUND_MAP = new_recursive_definition ground_RECUR
 `(!f:A->B x. GROUND_MAP f (VAL x) = VAL (f x)) /\
  (!f:A->B u v. GROUND_MAP f (VAPP u v) =
                VAPP (GROUND_MAP f u) (GROUND_MAP f v))`;;

let GROUND_MAP_GROUND_MAP = prove
 (`!f g x:A ground. GROUND_MAP f (GROUND_MAP g x) = GROUND_MAP (f o g) x`,
  GEN_TAC THEN GEN_TAC THEN MATCH_MP_TAC ground_INDUCT THEN
  REWRITE_TAC[GROUND_MAP; o_THM] THEN REPEAT STRIP_TAC THEN
  ASM_REWRITE_TAC[]);;

let GROUND_MAP_I = prove
 (`GROUND_MAP (I:A->A) = I`,
  REWRITE_TAC[FUN_EQ_THM] THEN MATCH_MP_TAC ground_INDUCT THEN
  REWRITE_TAC[GROUND_MAP; I_THM] THEN REPEAT STRIP_TAC THEN
  ASM_REWRITE_TAC[]);;

let GROUND_DBMODULE = new_definition
  `GROUND_DBMODULE (t:A dbmonad) =
   MK_DBMODULE (t,GROUND_MAP o DBBIND t)`;;

let GROUND_DBMODULE_CLAUSES = prove
 (`INFINITE (:A)
   ==> (!t:A dbmonad. DBBASE (GROUND_DBMODULE t) = t) /\
       (!t:A dbmonad f.
          DBMBIND (GROUND_DBMODULE t) f = GROUND_MAP (DBBIND t f))`,
  DISCH_TAC THEN
  SUBGOAL_THEN `!t:A dbmonad. IS_DBMODULE(t,GROUND_MAP o DBBIND t)`
    (fun th -> ASM_SIMP_TAC[th; GROUND_DBMODULE; DBBASE_MK_DBMODULE;
                            DBMBIND_MK_DBMODULE; o_THM]) THEN
  GEN_TAC THEN  REWRITE_TAC[IS_DBMODULE; GROUND_MAP_GROUND_MAP; o_THM] THEN
  REPEAT STRIP_TAC THENL
  [TRANS_TAC EQ_TRANS `GROUND_MAP I x:A ground` THEN
   CONJ_TAC THENL
   [AP_THM_TAC THEN AP_TERM_TAC THEN
    REWRITE_TAC[FUN_EQ_THM; I_THM; DBUNIT_DBBIND];
    REWRITE_TAC[GROUND_MAP_I; I_THM]];
   AP_THM_TAC THEN AP_TERM_TAC THEN
   REWRITE_TAC[FUN_EQ_THM; o_THM; DBBIND_DBBIND]]);;
