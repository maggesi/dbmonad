(* ========================================================================= *)
(*  More definitions and theorems and tactics about lists.                   *)
(*                                                                           *)
(*  Author: Marco Maggesi                                                    *)
(*          University of Florence, Italy                                    *)
(*          http://www.math.unifi.it/~maggesi/                               *)
(*                                                                           *)
(*          (c) Copyright, Marco Maggesi 2005 2006 2017                      *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(*  Proof that dblambda and LC are operads.                                  *)
(* ------------------------------------------------------------------------- *)

let DBLAMBDA_DBMONAD = prove
 (`DBMONAD SUBST`,
  REWRITE_TAC[DBMONAD_DEF; SUBST_SUBST; o_DEF] THEN
  EXISTS_TAC `REF` THEN REWRITE_TAC[SUBST; SUBST_REF]);;

let DBLAMBDA_DBMONAD_UNIT = prove
 (`DBMONAD_UNIT SUBST = REF`,
  MATCH_MP_TAC DBMONAD_UNIT_UNIQUE THEN
  REWRITE_TAC[DBLAMBDA_DBMONAD; SUBST; SUBST_REF]);;

let LC_DBMONAD = prove
 (`DBMONAD LC_SUBST`,
  REWRITE_TAC[DBMONAD_DEF; LC_SUBST_SUBST; o_DEF] THEN
  EXISTS_TAC `LC_REF` THEN
  REWRITE_TAC[LC_SUBST_RUNIT; LC_SUBST_LUNIT]);;

let LC_DBMONAD_UNIT = prove
 (`DBMONAD_UNIT LC_SUBST = LC_REF`,
  MATCH_MP_TAC DBMONAD_UNIT_UNIQUE THEN
  REWRITE_TAC[LC_DBMONAD; LC_SUBST_LUNIT; LC_SUBST_RUNIT]);;

(* ------------------------------------------------------------------------- *)
(*  Proof that LC is an exponential operad.                                  *)
(* ------------------------------------------------------------------------- *)

let LC_DMOP = prove
 (`!k f x. DMOP k LC_SUBST LC_SUBST (LC_PROJ o f) (LC_PROJ x) =
     LC_PROJ (DMOP k SUBST SUBST f x)`,
  REPEAT GEN_TAC THEN
  REWRITE_TAC[DMOP; DBLAMBDA_DBMONAD_UNIT;
              LC_DBMONAD_UNIT; GSYM LC_SUBST_PROJ] THEN
  MATCH_MP_TAC LC_SUBST_FUN_EXTENS THEN GEN_TAC THEN
  REWRITE_TAC[FUN_EQ_THM] THEN COND_CASES_TAC THEN
  ASM_REWRITE_TAC[GSYM LC_SUBST_PROJ; o_THM; LC_REF] THEN
  MATCH_MP_TAC LC_SUBST_FUN_EXTENS THEN REWRITE_TAC[o_THM]);;

let LC_ABS_MODULE_MOR = prove
 (`MODULE_MOR LC_SUBST (DMOP (SUC 0) LC_SUBST LC_SUBST) LC_SUBST LC_ABS`,
  SIMP_TAC[MODULE_MOR; SELF_MODULE; LC_DBMONAD; MODULE_DMOP] THEN
  REWRITE_TAC[FORALL_LC_THM; FORALL_LC_FUN_THM; LC_DMOP;
              LC_ABS; LC_SUBST_PROJ] THEN
  REPEAT GEN_TAC THEN REWRITE_TAC[SUBST; DMOP; DBLAMBDA_DBMONAD_UNIT] THEN
  REPEAT AP_TERM_TAC THEN REWRITE_TAC[SUBST_EXTENS] THEN
  NUM_CASES_TAC THEN DISCH_TAC THEN REWRITE_TAC[LT_0; DERIV; LT_SUC] THEN
  REWRITE_TAC[LT; SUB_SUC; SUB_0; ADD; REINDEX_EQ_SUBST; o_DEF]);;

let LC_APP0_MODULE_MOR = prove
 (`MODULE_ISOM LC_SUBST LC_SUBST (DMOP (SUC 0) LC_SUBST LC_SUBST)
               LC_APP0 LC_ABS`,
  MESON_TAC[MODULE_ISOM_SYM; LC_APP0_ABS; LC_ABS_APP0;
            MODULE_ISOM; LC_ABS_MODULE_MOR]);;

let LC_EXP = prove
 (`EXP_DBMONAD LC_SUBST LC_APP0 LC_ABS`,
  REWRITE_TAC[EXP_DBMONAD; LC_APP0_MODULE_MOR]);;

(* ------------------------------------------------------------------------- *)
(*  Proof of the universal property of LC                                    *)
(* ------------------------------------------------------------------------- *)

let EXP_DBMONAD_UNFOLD = prove
 (`!op h:A->A g.
     EXP_DBMONAD op h g <=>
     DBMONAD op /\
     (!x. g (h x) = x) /\
     (!y. h (g y) = y) /\
     (!f x. h (op f x) =
            op (\i. if i = 0 then DBMONAD_UNIT op i else
                    op (DBMONAD_UNIT op o SUC) (f (PRE i)))
               (h x)) /\
     (!f x. op f (g x) =
            g (op (\i. if i = 0 then DBMONAD_UNIT op i else
                       op (DBMONAD_UNIT op o SUC) (f (PRE i)))
                  x))`,
  REPEAT GEN_TAC THEN
  REWRITE_TAC[EXP_DBMONAD; SELF_MODULE; MODULE_ISOM_UNFOLD; MODULE_MOR;
    DMOP; CONJ_ACI; ADD; LT; o_DEF; ARITH_RULE `n - SUC 0 = PRE n`] THEN
  EQ_TAC THEN REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC MODULE_DMOP THEN ASM_REWRITE_TAC[SELF_MODULE]);;

let DBLAMBDA_EXP_MAP = new_recursive_definition dblambda_RECURSION
  `(!op h g:A->A i. DBLAMBDA_EXP_MAP op h g (REF i) = DBMONAD_UNIT op i) /\
   (!op h g x y.
      DBLAMBDA_EXP_MAP op h g (APP x y) =
        op (\n. if n = 0 then DBLAMBDA_EXP_MAP op h g y else
                DBMONAD_UNIT op (PRE n)) (h (DBLAMBDA_EXP_MAP op h g x))) /\
   (!op h g x. DBLAMBDA_EXP_MAP op h g (ABS x) =
               g (DBLAMBDA_EXP_MAP op h g x))`;;

let DBLAMBDA_EXP_MAP_REINDEX = prove
 (`!op h:A->A g x f.
     EXP_DBMONAD op h g
     ==> DBLAMBDA_EXP_MAP op h g (REINDEX f x) =
         op (DBMONAD_UNIT op o f) (DBLAMBDA_EXP_MAP op h g x)`,
  REWRITE_TAC[RIGHT_FORALL_IMP_THM] THEN REPEAT GEN_TAC THEN
  REWRITE_TAC[EXP_DBMONAD_UNFOLD] THEN STRIP_TAC THEN
  DBLAMBDA_INDUCT_TAC THEN GEN_TAC THEN
  REWRITE_TAC[REINDEX; DBLAMBDA_EXP_MAP] THENL
  [ASM_SIMP_TAC[DBMONAD_RUNIT; o_THM];
   ASM_SIMP_TAC[DBMONAD_ASSOC] THEN AP_THM_TAC THEN AP_TERM_TAC THEN
   REWRITE_TAC[FUN_EQ_THM] THEN NUM_CASES_TAC THEN
   ASM_SIMP_TAC[DBMONAD_LUNIT; DBMONAD_RUNIT; DBMONAD_ASSOC;
                o_THM; PRE; NOT_SUC];
   ASM_SIMP_TAC[DBLAMBDA_EXP_MAP; o_THM] THEN AP_TERM_TAC THEN
   AP_THM_TAC THEN AP_TERM_TAC THEN REWRITE_TAC[FUN_EQ_THM; o_THM] THEN
   NUM_CASES_TAC THEN REWRITE_TAC[SLIDE; NOT_SUC; PRE] THEN
   ASM_SIMP_TAC[DBMONAD_RUNIT; o_THM]]);;


let DBLAMBDA_EXP_MAP_SUBST = prove
 (`!op h:A->A g x f.
     EXP_DBMONAD op h g
     ==> DBLAMBDA_EXP_MAP op h g (SUBST f x) =
         op (DBLAMBDA_EXP_MAP op h g o f) (DBLAMBDA_EXP_MAP op h g x)`,
  REWRITE_TAC[RIGHT_FORALL_IMP_THM] THEN REPEAT GEN_TAC THEN
  INTRO_TAC "exp" THEN FIRST_ASSUM (MP_TAC) THEN
  REWRITE_TAC[EXP_DBMONAD_UNFOLD] THEN STRIP_TAC THEN
  DBLAMBDA_INDUCT_TAC THEN GEN_TAC THEN
  REWRITE_TAC[SUBST; DBLAMBDA_EXP_MAP] THENL
  [ASM_SIMP_TAC[DBMONAD_RUNIT; o_THM];
   ASM_SIMP_TAC[DBMONAD_ASSOC] THEN AP_THM_TAC THEN AP_TERM_TAC THEN
   REWRITE_TAC[FUN_EQ_THM] THEN NUM_CASES_TAC THEN
   ASM_SIMP_TAC[DBMONAD_RUNIT; DBMONAD_ASSOC; DBMONAD_LUNIT;
                ETA_AX; o_THM; PRE; NOT_SUC];
   ASM_REWRITE_TAC[] THEN AP_TERM_TAC THEN AP_THM_TAC THEN AP_TERM_TAC THEN
   REWRITE_TAC[FUN_EQ_THM] THEN NUM_CASES_TAC THEN
   REWRITE_TAC[DERIV; DBLAMBDA_EXP_MAP; o_THM; NOT_SUC; PRE] THEN
   ASM_SIMP_TAC[DBLAMBDA_EXP_MAP_REINDEX]]);;


let DBLAMBDA_EXP_MAP_REL = prove
 (`!op h:A->A g x y.
     EXP_DBMONAD op h g /\ x === y
     ==> DBLAMBDA_EXP_MAP op h g x = DBLAMBDA_EXP_MAP op h g y`,
  INTRO_TAC "!op h g" THEN REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM] THEN
  INTRO_TAC "exp" THEN FIRST_ASSUM MP_TAC THEN
  REWRITE_TAC[EXP_DBMONAD_UNFOLD] THEN STRIP_TAC THEN
  MATCH_MP_TAC LC_REL_INDUCT THEN CONJ_TAC THENL
  [MATCH_MP_TAC DBLAMBDA_BETA_INDUCT THEN GEN_TAC THEN GEN_TAC THEN
   REWRITE_TAC[DBLAMBDA_EXP_MAP] THEN ASM_SIMP_TAC[DBLAMBDA_EXP_MAP_SUBST] THEN
   AP_THM_TAC THEN AP_TERM_TAC THEN REWRITE_TAC[FUN_EQ_THM] THEN
   NUM_CASES_TAC THEN
   REWRITE_TAC[WEAKEN; DBLAMBDA_EXP_MAP; o_THM; NOT_SUC; PRE];
   ALL_TAC] THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC DBLAMBDA_ETA_INDUCT THEN GEN_TAC THEN
  REWRITE_TAC[DBLAMBDA_EXP_MAP] THEN
   ASM_SIMP_TAC[DBLAMBDA_EXP_MAP_REINDEX; DBMONAD_ASSOC;
                DBMONAD_RUNIT; o_THM] THEN
   SUBGOAL_THEN
     `(\n. op (\n. if n = 0
                   then DBMONAD_UNIT op 0
                   else DBMONAD_UNIT op (PRE n))
       (if n = 0
        then DBMONAD_UNIT op 0
        else DBMONAD_UNIT op (SUC (SUC (PRE n))))) =
      DBMONAD_UNIT (op:(num->A)->A->A)`
     SUBST1_TAC THENL
   [REWRITE_TAC[FUN_EQ_THM] THEN NUM_CASES_TAC THEN
    ASM_SIMP_TAC[DBMONAD_RUNIT; NOT_SUC; PRE];
    ASM_SIMP_TAC[DBMONAD_LUNIT]];
   ALL_TAC] THEN
  REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[DBLAMBDA_EXP_MAP]);;

let LC_EXP_MAP = define
  `!op h g:A->A x. LC_EXP_MAP op h g x = DBLAMBDA_EXP_MAP op h g (LC_LIFT x)`;;

g `!op h:A->A g x.
     EXP_DBMONAD op h g
     ==> LC_EXP_MAP op h g (LC_PROJ x) = DBLAMBDA_EXP_MAP op h g x`;;
e (REPEAT GEN_TAC THEN DISCH_TAC);;
e (REWRITE_TAC[LC_EXP_MAP]);;
e (MATCH_MP_TAC DBLAMBDA_EXP_MAP_REL);;
e (ASM_REWRITE_TAC[LC_LIFT_PROJ]);;
let LC_EXP_MAP_FACTOR = top_thm ();;

g `!op h:A->A g.
      EXP_DBMONAD op h g
      ==> DBMONAD_MOR LC_SUBST op (LC_EXP_MAP op h g)`;;
e (REPEAT STRIP_TAC);;
e (FIRST_ASSUM (STRIP_ASSUME_TAC o REWRITE_RULE [EXP_DBMONAD_UNFOLD]));;
e (ASM_REWRITE_TAC[DBMONAD_MOR; LC_DBMONAD]);;
e (REWRITE_TAC[LC_DBMONAD_UNIT; LC_REF]);;
e (ASM_SIMP_TAC[LC_EXP_MAP_FACTOR; DBLAMBDA_EXP_MAP]);;
e (REWRITE_TAC[LC_SUBST_DEF]);;
e (ASM_SIMP_TAC[LC_EXP_MAP_FACTOR]);;
e (ASM_SIMP_TAC[DBLAMBDA_EXP_MAP_SUBST]);;
e (REWRITE_TAC[LC_EXP_MAP; o_DEF]);;
let DBMONAD_MOR_LC_EXP_MAP = top_thm ();;

g `!op h:A->A g.
     EXP_DBMONAD op h g
     ==>
     (!i. DBLAMBDA_EXP_MAP op h g (REF i) = DBMONAD_UNIT op i) /\
     (!x. DBLAMBDA_EXP_MAP op h g (APP0 x) = h (DBLAMBDA_EXP_MAP op h g x)) /\
     (!x. DBLAMBDA_EXP_MAP op h g (ABS x) = g (DBLAMBDA_EXP_MAP op h g x)) /\
     (!t x. DBLAMBDA_EXP_MAP op h g (SUBST t x) =
            op (DBLAMBDA_EXP_MAP op h g o t) (DBLAMBDA_EXP_MAP op h g x))`;;
e (REPEAT GEN_TAC THEN DISCH_TAC);;
e (FIRST_ASSUM (STRIP_ASSUME_TAC o REWRITE_RULE [EXP_DBMONAD_UNFOLD]));;
e (ASM_REWRITE_TAC[APP0; DBLAMBDA_EXP_MAP]);;
e (REPEAT STRIP_TAC);;
e (ASM_SIMP_TAC[DBLAMBDA_EXP_MAP_REINDEX; DBMONAD_ASSOC]);;
e (MATCH_MP_TAC DBMONAD_LUNIT_IMP);;
e (ASM_REWRITE_TAC[TRIVIAL_ARITH]);;
e (GEN_TAC THEN COND_CASES_TAC);;
e (ASM_SIMP_TAC[DBMONAD_RUNIT]);;
e (ASM_SIMP_TAC[DBMONAD_ASSOC; o_THM]);;
e (ASM_SIMP_TAC[ARITH_RULE `~(i = 0) ==> SUC (PRE i) = i`]);;
e (MATCH_MP_TAC DBMONAD_LUNIT_IMP);;
e (ASM_REWRITE_TAC[o_THM]);;
e (ASM_SIMP_TAC[DBMONAD_RUNIT]);;
e (REWRITE_TAC[NOT_SUC; PRE]);;
e (ASM_SIMP_TAC[DBLAMBDA_EXP_MAP_SUBST]);;
let DBLAMBDA_EXP_MAP_ALT = top_thm ();;

g `!op h:A->A g.
      EXP_DBMONAD op h g
      ==> EXP_DBMONAD_MOR LC_SUBST LC_APP0 LC_ABS
                          op h g (LC_EXP_MAP op h g)`;;
e (REPEAT STRIP_TAC);;
e (FIRST_ASSUM (STRIP_ASSUME_TAC o REWRITE_RULE [EXP_DBMONAD_UNFOLD]));;
e (ASM_REWRITE_TAC[EXP_DBMONAD_MOR; LC_EXP]);;
e (ASM_SIMP_TAC[DBMONAD_MOR_LC_EXP_MAP]);;
e (REWRITE_TAC[FORALL_LC_THM]);;
e (ASM_SIMP_TAC[LC_EXP_MAP_FACTOR; LC_APP0]);;
e (ASM_SIMP_TAC[DBLAMBDA_EXP_MAP_ALT]);;
let EXP_DBMONAD_MOR_LC_EXP_MAP = top_thm ();;

g `!op1 h1 g1 op2 h2 g2 f:A->B.
      EXP_DBMONAD_MOR op1 h1 g1 op2 h2 g2 f
      <=> EXP_DBMONAD op1 h1 g1 /\
          EXP_DBMONAD op2 h2 g2 /\
          DBMONAD_MOR op1 op2 f /\
          (!x. h2 (f x) = f (h1 x)) /\
          (!x. g2 (f x) = f (g1 x))`;;
e (REPEAT GEN_TAC THEN REWRITE_TAC[EXP_DBMONAD_MOR] THEN
   EQ_TAC THENL [ALL_TAC; MESON_TAC[]]);;
e (DISCH_THEN (fun th -> REWRITE_TAC[th] THEN MP_TAC th));;
e (REWRITE_TAC[EXP_DBMONAD; MODULE_ISOM_UNFOLD; MODULE_MOR]);;
e (REWRITE_TAC[CONJ_ACI]);;
e (STRIP_TAC THEN GEN_TAC);;
e (SUBGOAL_THEN `!x y : B. h2 x :B = h2 y ==> x = y` MATCH_MP_TAC);;
e (ASM_MESON_TAC[]);;
e (ASM_REWRITE_TAC[]);;
let EXP_DBMONAD_MOR_FACTS = top_thm ();;

g `!op h:A->A g m.
      EXP_DBMONAD op h g /\
      EXP_DBMONAD_MOR LC_SUBST LC_APP0 LC_ABS op h g m
      ==> m = LC_EXP_MAP op h g`;;
e (REPEAT STRIP_TAC);;
e (STRIP_ASSUME_TAC
    (REWRITE_RULE [EXP_DBMONAD_UNFOLD]
                  (ASSUME `EXP_DBMONAD op (h:A->A) g`)));;
e (STRIP_ASSUME_TAC
     (REWRITE_RULE [EXP_DBMONAD_MOR_FACTS; LC_EXP]
                   (ASSUME `EXP_DBMONAD_MOR LC_SUBST LC_APP0 LC_ABS
                                           op (h:A->A) g m`)));;
e (STRIP_ASSUME_TAC
    (REWRITE_RULE [DBMONAD_MOR; LC_DBMONAD]
                  (ASSUME `DBMONAD_MOR LC_SUBST op (m:lc->A)`)));;
e (REWRITE_TAC[FUN_EQ_THM]);;
e (REWRITE_TAC[FORALL_LC_THM]);;
e (ASM_SIMP_TAC[LC_EXP_MAP_FACTOR]);;
e (DBLAMBDA_INDUCT_TAC);;
e (ASM_REWRITE_TAC[GSYM LC_REF; GSYM LC_DBMONAD_UNIT; DBLAMBDA_EXP_MAP]);;
e (ASM_REWRITE_TAC[GSYM LC_APP; LC_APP_APP0; DBLAMBDA_EXP_MAP]);;
e (SUBGOAL_THEN `m (LC_APP0 (LC_PROJ a0)) :A = h (DBLAMBDA_EXP_MAP op h g a0)`
    SUBST1_TAC);;
e (ASM_MESON_TAC[]);;
e (AP_THM_TAC THEN AP_TERM_TAC);;
e (REWRITE_TAC[FUN_EQ_THM; o_THM]);;
e (GEN_TAC THEN COND_CASES_TAC THEN ASM_REWRITE_TAC[]);;
e (ASM_REWRITE_TAC[GSYM LC_DBMONAD_UNIT]);;
e (ASM_REWRITE_TAC[GSYM LC_ABS; DBLAMBDA_EXP_MAP]);;
e (ASM_MESON_TAC[]);;
let LC_EXP_MAP_UNIQUE = top_thm ();;
