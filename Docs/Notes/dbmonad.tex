\documentclass[a4paper,twoside,12pt]{article}

\usepackage{amsthm,amsmath,amssymb}

\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\theoremstyle{remark}
\newtheorem{remark}{Remark}

\DeclareMathOperator{\Ob}{Ob}

\newcommand{\NN}{\mathbb{N}}
\newcommand{\subst}{\mathtt{subst}}
\newcommand{\refe}{\mathtt{ref}}
\newcommand{\reindex}{\mathtt{reindex}}
\newcommand{\TT}{\mathtt{T}}
\newcommand{\MM}{\mathtt{M}}
\newcommand{\msubst}{\mathtt{msubst}}

\title{De Bruijn Monads}
\author{Andr\'e Hirschowitz \and Marco Maggesi}
\date{April 2017}

\begin{document}
\maketitle

\begin{abstract}
  We focus on a special class of (relative) monads which arise
  naturally in the implementation of higher-order syntax with the de
  Bruijn encoding.  We develop the algebraic theory of such \emph{de
    Bruijn monads} (\emph{dB-monads}) and we show how they can be used
  to easily extrapolate several useful \emph{fusion laws} which
  otherwise might be tricky to devise.  Finally we develop a theory of
  initial semantics for algebraic syntax in this framework.
\end{abstract}

\tableofcontents{}

\section{Introduction}
\label{sec:intro}
To be done.
Advantages:
\begin{itemize}
\item Help to reason about de Bruijn encoding: write \emph{fusion
    laws} without pain.
\item Simple: just three easy axioms, category-theoretic in nature,
  but Category Theory not strictly required.
\item Basic: can be formalized idiomatically in HOL, no dependent
  types required.
\end{itemize}

\section{Basic definitions and examples}
\label{sec:basic-def}

\subsection{Definition of dB-monad}
\label{sec:basic-defin-example}

\begin{definition}[dB-monad]
  A \emph{dB-monad} is given by a type $\TT$ and two functions
  \begin{align*}
    \refe &\colon \NN \to \TT, \\
    \subst &\colon (\NN \to \TT) \to \TT \to \TT
  \end{align*}
  called \emph{reference} and \emph{substitution}, satisfying the
  following three conditions\footnote{For function application we
    follow the convention of implicit currying as in the HoTT Book,
    e.g., $f(x,y) = f(x)(y) = (f(x))(y)$.}
  \begin{align*}
    \subst(f,\refe(i)) &=  f(i)
    && \text{right unital law} \\
    \subst(\refe, x) &=  x
    && \text{left unital law} \\
    \subst(f, \subst(g, x)) &= \subst(\subst(f) \circ g, x)
    &&\text{associativity law}
  \end{align*}
  for all $x : \TT$, $i :\NN$ and $f,g\colon \NN \to \TT$.
\end{definition}

We will simply call $\TT$ the dB-monad
$\langle \TT, \refe, \subst \rangle$ whenever no confusion can arise.
The type $\TT$ itself will be referred as the \emph{carrier} of the
dB-monad.

\subsection{Examples of dB-monads}
\label{sec:examples-dB-monads}

We now consider some basic examples of dB-monads.

\paragraph{The identity dB-monad}

The type $\NN$ of natural numbers has a trivial structure of dB-monad
with $\refe(i) \stackrel{\mathsf{def}}{=} i$ and
$\subst(f,i) \stackrel{\mathsf{def}}{=} f(i)$.

\paragraph{The dB-monad of lists}

A less trivial example is the \emph{free monoid dB-monad} (which might
well also called \emph{free monoid dB-monad}) defined as follows:
\begin{align*}
T &\stackrel{\mathsf{def}}{=}\mathtt{list}(\NN) && \text{the type of lists of natural numbers} \\
\refe(i) &\stackrel{\mathsf{def}}{=} [i] &&\text{the singleton list} \\
\subst(f,[x_1, \dots, x_n] &\stackrel{\mathsf{def}}{=} f(x_1) + \cdots + f(x_n)
\end{align*}
where `$+$' in the last identity denotes the concatenation of lists.

\paragraph{The dB-monad associated to a monad}

Given a monad $M$ on $\mathsf{Set}$ (the category of small sets),
$\TT \stackrel{\mathsf{def}}{=} M(\NN)$ has a natural structure of
dB-monad where $\refe = \eta_\NN$ and
$\subst(f) \stackrel{\mathsf{def}}{=} \mathsf{bind}(f)$.

Indeed, our previous example about the dB-monad of lists is precisely
the dB-monad associated to the monad of lists.

\paragraph{TODO: The dB-monad associated to a relative monad(?)}

dB-monads are relative monad on $J\colon \langle \NN
\rangle \to \mathsf{Set}$.

Can we consider more general $J$?

Of course (see previous paragraph ``The dB-monad associated to a
monad'') we can take take the identity $J:\mathsf{Set} \to
\mathsf{Set}$.

More generally, I suspect that anything with target into
$\mathsf{Set}$ should work.  Is that the case?


\paragraph{TODO: (relative?) monad associated to a dB-monad}

[Left Kan extension sould provide us with everything we need.]

\paragraph{dB-monad of $\lambda$-calculus}

For now, we simply introduce the dB-monad $\mathsf{\Lambda}$ of
(syntactic) $\lambda$-calculus as the one associated to the
corresponding monad $\Lambda$, as stated before.  Later we will
discuss a more explicit construction of $\mathtt{\Lambda}$.

\subsection{dB-monads and relative monads}
\label{sec:subst-rel-monads}

\begin{definition}[Relative monad]
  A \emph{relative monad} over a functor
  $J\colon \mathsf{J}\to \mathsf{C}$ is given by
  \begin{itemize}
  \item a mapping $M:\Ob \mathsf{J} \to \mathsf{C}$;
  \item for every object $X$ of $\mathsf{J}$, an arrow $\eta_X\colon
    J(X) \to M(X)$;
  \item for every pair of objects $X,Y$ of $\mathsf{J}$, and for every
    arrow $f\colon J(X) \to M(Y)$, a \emph{Kleisli extension}
    $\sigma(f) \colon M(X) \to M(Y)$
  \end{itemize}
  satisfying the identities
  \begin{align*}
    \sigma(f) \circ \eta &= f &&\text{right unital law} \\
    \sigma(\eta_X) &= \mathsf{id}_{M(X)} &&\text{left unital law} \\
    \sigma(f) \circ \sigma(g) &= \sigma(\sigma(f) \circ g) &&\text{associativity law}
  \end{align*}
  for all objects $X,Y,Z$ of $\mathsf{J}$ and forall arrows
  $f\colon J(Y)\to M(Z)$, $g\colon J(X)\to M(Y)$.
\end{definition}

We are going to show how a dB-monad $\TT$ has a natural structure of
relative monad.  Take
$\mathsf{J} \stackrel{\mathsf{def}}{=}\langle \NN \rangle$ (the full
subcategory of $\mathsf{Set}$ generated by $\NN$) and
\begin{equation}
  \label{eq:functor_J}
  J\colon \langle \NN \rangle \to \mathsf{Set}
\end{equation}
the inclusion functor.

\begin{proposition}[Relative monad over $J$ associated to a dB-monad]
  Given a dB-monad $\TT$, define
  \begin{align*}
    M(\NN) &\stackrel{\mathsf{def}}{=} \TT, \\
    \eta_\NN &\stackrel{\mathsf{def}}{=} \refe, \\
    \sigma &\stackrel{\mathsf{def}}{=} \subst.
  \end{align*}
  Then $M,\eta,\sigma$ is a relative monad over $J$.
\end{proposition}

% \subsection{dB-monads and relative monads -- alternative version(?)}
% \label{sec:subst-rel-monads-alt}

% Alternative(?) construction of the relative monad associated to a
% dB-monad.

% [The construction in the previous section has at least one advantage
% with respect to the one presented here, namely, the functor $J$ is
% independent from the particular dB-monad.  This section will be
% deleted in the future, but for now, let's keep record of this
% alternative construction.]

% \begin{itemize}
% \item $\mathsf{J}\stackrel{\mathsf{def}}{=}*$ the final category
%   (i.e., the category with just one object and one arrow),
% \item $\mathsf{C}\stackrel{\mathsf{def}}{=}\langle\NN\rangle$ the
%   monoid given by the maps $\NN\to\NN$ (in other words, the full
%   subcategory of $\mathsf{Set}$ generated by $\NN$);
% \item $J\colon \mathsf{J} \to \mathsf{C}$ the natural injection.
% \end{itemize}

% \begin{proposition}[Every dB-monad is relative monad over $J$]
%   Given a dB-monad $\TT$, define
%   \begin{align*}
%     M(*) &\stackrel{\mathsf{def}}{=} \TT, \\
%     \eta_* &\stackrel{\mathsf{def}}{=} \refe, \\
%     \sigma &\stackrel{\mathsf{def}}{=} \subst.
%   \end{align*}
%   Then $M,\eta,\sigma$ is a relative monad over $J$.
% \end{proposition}

\subsection{Functoriality of dB-monads}
\label{sec:further-operators-db}

Given a dB-monad $\TT$ we can define the \emph{reindex} operator
\begin{equation*}
  \reindex\colon (\NN \to \NN) \to (\TT \to \TT)
\end{equation*}
given by
\begin{equation*}
  \reindex(f,x) = \subst(\refe \circ f, x).
\end{equation*}
It is straightforward to verify, from the axioms of dB-monad, that the
following \emph{fusion} laws holds for $\reindex$:
\begin{align*}
  \reindex(f,\refe(i)) &= \refe(f(i)) \\
  \reindex(\refe,x) &= x \\
  \reindex(f,\subst(g,x)) &= \subst(\reindex(f) \circ g, x) \\
  \subst(f,\reindex(g,x)) &= \subst(f \circ g,x) \\
  \reindex(f,\reindex(g,x)) &= \reindex(f\circ g, x) \\
\end{align*}

\subsection{Morphisms of dB-monads}
\label{sec:morphisms-db-monads}

\begin{definition}[Morphisms of dB-monad]
  Given two dB-monads $\TT_1$, $\TT_2$ with substitutions $\subst_1$,
  $\subst_2$ and references $\refe_1$, $\refe_2$ a \emph{morphism} of
  dB-monads is a function $\phi\colon \TT_1 \to \TT_2$ such that
  satisfies the  identities
  \begin{align*}
    \phi(\refe_1(i)) &= \refe_2(i) \\
    \phi(\subst_1(f,x)) &= \subst_2(\phi \circ f, \phi(x))
  \end{align*}
  for all $i \in \NN$ and $f\colon \NN \to \TT_1$.
\end{definition}

It is immediate to verify that the previous definition builds
dB-monads into a category $\mathsf{dB}$ which is precisely, the
category of relative monads over the functor $J$ of
\eqref{eq:functor_J}.

It follows at once that morphisms of dB-monads commute with
reindexing, that is, for all $\phi\colon \TT_1 \to \TT_2$,
$x\in \TT_1$ and $f\colon \NN\to \NN$ we have
\begin{equation*}
  \phi(\reindex_1(f,x)) = \reindex_2(f,\phi(x)) .
\end{equation*}

\subsection{Free references}
\label{sec:free-references}

\textbf{TODO: Definition of \emph{Free Reference}:}
Define 'free references' in the theory of dB-monads:
\begin{enumerate}
\item As an example, consider $\Lambda$, the dB-monad of
  $\lambda$-calculus (syntactic or semantic as you prefer).
\item It is easy to define inductive relation
  $i\ \mathtt{free\_in}\ x$.
\item The key property is
  \begin{equation*}
    \subst(f,x) = x \Longleftrightarrow
    (\forall i.\, i\ \mathtt{free\_in}\ x \Longrightarrow f\ i = i)
  \end{equation*}
\item \textbf{Question:} Can we turn the above theorem into a
  \emph{dB-monadic} definition of \emph{free reference}?
\end{enumerate}

\section{Modules over dB-monads}
\label{sec:modules}

As for monad we have an associated notion of module, there is a
parallel notion of \emph{dB-module over dB-monads}.

\subsection{Definition of dB-module}
\label{sec:definition-module}

\begin{definition}[Modules of a dB-monad]
  A \emph{dB-module} (or simply \emph{module}) of a dB-monad $\TT$ is
  a type $\MM$ with an \emph{action}
  \begin{equation*}
    \msubst\colon (\NN\to \TT) \to \MM \to \MM
  \end{equation*}
  satisfying the laws
  \begin{align*}
    \msubst(\refe,x) &= x\\
    \msubst(f,\msubst(g,x)) &= \msubst(\subst f \circ g, x)
  \end{align*}
  for all $x\in \MM$ and $f,g\colon \NN \to \TT$.
\end{definition}

\subsection{Examples of modules}
\label{sec:examples-modules}

\paragraph{The trivial module}

Every dB-monad is a module over itself in an obvious way.

\paragraph{Modules associated to modules of a monad}

Let $R$ be a monad over $\mathsf{Set}$.  Given a module $M$ over $R$,
$M(\NN)$ has a natural structure of module over the dB-monad $R(\NN)$.

\paragraph{Arbitrary products of modules}

Let $\TT$ be a dB-monad.  Arbitrary products of modules over $\TT$
are, in an obvious way, modules over $\TT$ (see also Proposition
\ref{prop:modules-product}).

\subsection{Morphisms of dB-modules}
\label{sec:morphisms-db-modules}

In this section $\TT$ will be a fixed dB-monad.

\begin{definition}[Morphisms of dB-modules]
  Let $\MM_1$, $\MM_2$ two $\TT$-modules with actions $\msubst_1$ and
  $\msubst_2$.  A $\TT$-\emph{linear morphism} (or \emph{morphism of
    $\TT$-modules} is a map $\phi\colon \MM_1 \to \MM_2$ compatible
  with the module actions in the following sense:
  \begin{equation*}
    \phi(\msubst_1(f,x)) = \msubst_2(f,\phi(x)).
  \end{equation*}
\end{definition}

The family of modules over a fixed monad together with their morphisms
forms a category that we denote $\mathsf{Mod}(\TT)$.

\begin{proposition}
  \label{prop:modules-product}
  The category $\mathsf{Mod}(\TT)$ has arbitrary products.
\end{proposition}

\subsection{Derived module}
\label{sec:derived-module}

Let $\MM$ be a module over the dB-monad $\TT$.

\begin{definition}[Derived dB-module]
  The \emph{derived dB-module} $\MM'$ of $\MM$ is a dB-module over
  $\TT$ given by the following structure:
  \begin{itemize}
  \item the carrier of $\MM'$ is the same as that of $\MM$,
  \item the action $\msubst'$ of $\MM'$ is defined by
    \begin{equation*}
    \msubst'(f,x) \stackrel{\mathsf{def}}{=} \msubst(f',x)
  \end{equation*}
  where $f'$ is defined by the equations:
  \begin{align*}
    f'(0) &= \refe(0)\\
    f'(i+1) &= \reindex(\mathtt{suc},f(i))
  \end{align*}
  and $\mathsf{suc} \colon \NN \to \NN$ denotes the \emph{successor
    function} ($\mathtt{suc}(i) = i+1$).
  \end{itemize}
\end{definition}

The necessary verification to establish that $\MM'$ is indeed a module
are easy.  A refined statement is given by the following proposition.

\begin{proposition}(Derivation as endofunctor)
  \label{prop:derivation-endo}
  Derivation yields a Cartesian endofunctor of $\mathsf{Mod}(\TT)$.
\end{proposition}

\section{Initial semantics with dB-monads}
\label{sec:init-semantics}

\subsection{Signatures and representations in dB-modules}
\label{sec:signatures-representations}

\begin{definition}[Arities and representations of arities]
  \hfill
  \begin{itemize}
  \item An \emph{arity} is a finite list of non-negative integer.
  \item Given a dB-monad $\TT$, a $\TT$-module $\MM$ and an arity
    $a=(a_1,\dots,a_n)$, a \emph{representation of the arity $a$ in
      $\MM$} is a $\TT$-linear morphism
    \begin{equation*}
      \phi:\MM^{(a_1)}\times\cdots\times\MM^{(a_n)} \longrightarrow \MM
    \end{equation*}
  \item A \emph{signature} is a family of arities.
  \item A \emph{representation of a signature} $\Sigma$ is given by a
    representation for each of its arities.
  \end{itemize}
\end{definition}

\end{document}

%  LocalWords: unital associativity monad monoid functor monads arity
%  LocalWords:  arities morphism morphisms
