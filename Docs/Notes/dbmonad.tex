\documentclass[a4paper,twoside,12pt]{article}

\usepackage{amsthm,amsmath,amssymb}

\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\theoremstyle{remark}
\newtheorem{remark}{Remark}

\DeclareMathOperator{\Ob}{Ob}

\newcommand{\NN}{\mathbb{N}}
\newcommand{\subst}{\mathtt{subst}}
\newcommand{\refe}{\mathtt{ref}}
\newcommand{\reindex}{\mathtt{reindex}}
\newcommand{\TT}{\mathtt{T}}
\newcommand{\MM}{\mathtt{M}}
\newcommand{\msubst}{\mathtt{msubst}}

\title{De Bruijn Monads}
\author{Andr\'e Hirschowitz \and Marco Maggesi}
\date{April 2017}

\begin{document}
\maketitle

\begin{abstract}
  We present a simple algebraic structure that helps to reason about
  higher-order syntax and semantics using de Bruijn's nameless
  encoding.
\end{abstract}

\section{Introduction}
\label{sec:intro}
To be done.
Advantages:
\begin{itemize}
\item Help to reason about de Bruijn encoding: write \emph{fusion
    laws} without pain.
\item Simple: just three easy axioms, category-theoretic in nature,
  but Category Theory not strictly required.
\item Basic: can be formalized idiomatically in HOL, no dependent
  types required.
\end{itemize}

\section{Basic definitions and examples}
\label{sec:basic-def}

\subsection{Definition of dB-monad}
\label{sec:basic-defin-example}

\begin{definition}[dB-monad]
  A \emph{dB-monad} is given by a type $\TT$ and two functions
  \begin{align*}
    \refe &\colon \NN \to \TT, \\
    \subst &\colon (\NN \to \TT) \to \TT \to \TT
  \end{align*}
  called \emph{reference} and \emph{substitution}, satisfying the
  following three conditions\footnote{For function application we
    follow the convention of implicit currying as in the HoTT Book,
    e.g., $f(x,y) = f(x)(y) = (f(x))(y)$.}
  \begin{align*}
    \subst(f,\refe(i)) &=  f(i)
    && \text{right unital law} \\
    \subst(\refe, x) &=  x
    && \text{left unital law} \\
    \subst(f, \subst(g, x)) &= \subst(\subst(f) \circ g, x)
    &&\text{associativity law}
  \end{align*}
  for all $x : \TT$, $i :\NN$ and $f,g\colon \NN \to \TT$.
\end{definition}

We will simply call $\TT$ the dB-monad
$\langle \TT, \refe, \subst \rangle$ whenever no confusion can ariese.
The type $\TT$ itself will be referred as the \emph{carrier} of the
dB-monad.

\subsection{Examples of dB-monads}
\label{sec:examples-dB-monads}

We now consider some basic examples of dB-monads.

\paragraph{The identity dB-monad}

The type $\NN$ of natural numbers has a trivial structure of dB-monad
with $\refe(i) \stackrel{\mathsf{def}}{=} i$ and
$\subst(f,i) \stackrel{\mathsf{def}}{=} f(i)$.

\paragraph{The dB-monad of lists}

A less trivial example is the \emph{free monoid dB-monad} (which might
well also called \emph{free monoid dB-monad}) defined as follows:
\begin{align*}
T &\stackrel{\mathsf{def}}{=}\mathtt{list}(\NN) && \text{the type of lists of natural numbers} \\
\refe(i) &\stackrel{\mathsf{def}}{=} [i] &&\text{the singleton list} \\
\subst(f,[x_1, \dots, x_n] &\stackrel{\mathsf{def}}{=} f(x_1) + \cdots + f(x_n)
\end{align*}
where `$+$' in the last identity denotes the concatenation of lists.

\paragraph{The dB-monad associated to a monad}

Given a monad $M$ on $\mathsf{Set}$ (the category of small sets),
$\TT \stackrel{\mathsf{def}}{=} M(\NN)$ has a natural structure of
dB-monad where $\refe = \eta_\NN$ and
$\subst(f) \stackrel{\mathsf{def}}{=} \mathsf{bind}(f)$.

Indeed, our previous example about the dB-monad of lists is precisely
the dB-monad associated to the monad of lists.

\paragraph{TODO: The dB-monad associated to a relative monad(?)}

[Should not be difficult to devise the correct definition, \emph{n'est
  pas}?  I guess we just need to require the appropriate condition on
the functor $J$.]

Left Kan extension.

\paragraph{dB-monad of $\lambda$-calculus}

For now, we simply introduce the dB-monad $\mathsf{\Lambda}$ of
(syntactic) $\lambda$-calculus as the one associated to the
corresponding monad $\Lambda$, as stated before.  Later we will
discuss a more explicit construction of $\mathtt{\Lambda}$.

\subsection{Functoriality of dB-monads}
\label{sec:further-operators-db}

Given a dB-monad $\TT$ we can define the \emph{reindex} operator
\begin{equation*}
  \reindex\colon (\NN \to \NN) \to (\TT \to \TT)
\end{equation*}
given by
\begin{equation*}
  \reindex(f,x) = \subst(\refe \circ f, x).
\end{equation*}
It is straightforward to verify, from the axioms of dB-monad, that the
following \emph{fusion} laws holds for $\reindex$:
\begin{align*}
  \reindex(f,\refe(i)) &= \refe(f(i)) \\
  \reindex(\refe,x) &= x \\
  \reindex(f,\subst(g,x)) &= \subst(\reindex(f) \circ g, x) \\
  \subst(f,\reindex(g,x)) &= \subst(f \circ g,x) \\
  \reindex(f,\reindex(g,x)) &= \reindex(f\circ g, x) \\
\end{align*}

\subsection{dB-monads and relative monads}
\label{sec:subst-rel-monads}

\begin{definition}[Relative monad]
  A \emph{relative monad} over a functor
  $J\colon \mathsf{J}\to \mathsf{C}$ is given by
  \begin{itemize}
  \item a mapping $M:\Ob \mathsf{J} \to \mathsf{C}$;
  \item for every object $X$ of $\mathsf{J}$, an arrow $\eta_X\colon
    J(X) \to M(X)$;
  \item for every pair of objects $X,Y$ of $\mathsf{J}$, and for every
    arrow $f\colon J(X) \to M(Y)$, a \emph{Kleisli extension}
    $\sigma(f) \colon M(X) \to M(Y)$
  \end{itemize}
  satisfying the identities
  \begin{align*}
    \sigma(f) \circ \eta &= f &&\text{right unital law} \\
    \sigma(\eta_X) &= \mathsf{id}_{M(X)} &&\text{left unital law} \\
    \sigma(f) \circ \sigma(g) &= \sigma(\sigma(f) \circ g) &&\text{associativity law}
  \end{align*}
  for all objects $X,Y,Z$ of $\mathsf{J}$ and forall arrows
  $f\colon J(Y)\to M(Z)$, $g\colon J(X)\to M(Y)$.
\end{definition}

We are going to show how a dB-monad $\TT$ has a natural structure of
relative monad.  Take
$\mathsf{J} \stackrel{\mathsf{def}}{=}\langle \NN \rangle$ (the full
subcategory of $\mathsf{Set}$ generated by $\NN$) and
$J\colon \langle \NN \rangle \to \mathsf{Set}$ the inclusion functor.

\begin{proposition}[Relative monad over $J$ associated to a dB-monad]
  Given a dB-monad $\TT$, define
  \begin{align*}
    M(\NN) &\stackrel{\mathsf{def}}{=} \TT, \\
    \eta_\NN &\stackrel{\mathsf{def}}{=} \refe, \\
    \sigma &\stackrel{\mathsf{def}}{=} \subst.
  \end{align*}
  Then $M,\eta,\sigma$ is a relative monad over $J$.
\end{proposition}

\subsection{dB-monads and relative monads -- alternative version(?)}
\label{sec:subst-rel-monads-alt}

Alternative(?) construction of the relative monad associated to a
dB-monad.

[The construction in the previous section has at least one advantage
with respect to the one presented here, namely, the functor $J$ is
independent from the particular dB-monad.  This section will be
deleted in the future, but for now, let's keep record of this
alternative construction.]

\begin{itemize}
\item $\mathsf{J}\stackrel{\mathsf{def}}{=}*$ the final category
  (i.e., the category with just one object and one arrow),
\item $\mathsf{C}\stackrel{\mathsf{def}}{=}\langle\NN\rangle$ the
  monoid given by the maps $\NN\to\NN$ (in other words, the full
  subcategory of $\mathsf{Set}$ generated by $\NN$);
\item $J\colon \mathsf{J} \to \mathsf{C}$ the natural injection.
\end{itemize}

\begin{proposition}[Every dB-monad is relative monad over $J$]
  Given a dB-monad $\TT$, define
  \begin{align*}
    M(*) &\stackrel{\mathsf{def}}{=} \TT, \\
    \eta_* &\stackrel{\mathsf{def}}{=} \refe, \\
    \sigma &\stackrel{\mathsf{def}}{=} \subst.
  \end{align*}
  Then $M,\eta,\sigma$ is a relative monad over $J$.
\end{proposition}

\subsection{Free references}
\label{sec:free-references}

\textbf{Open Problem(?), definition of \emph{Free Reference}:}
Define 'free references' in the theory of dB-monads:
\begin{enumerate}
\item As an example, consider $\Lambda$, the dB-monad of
  $\lambda$-calculus (syntactic or semantic as you prefer).
\item It is easy to define inductive relation
  $i\ \mathtt{free\_in}\ x$.
\item The key property is
  \begin{equation*}
    \subst(f,x) = x \Longleftrightarrow
    (\forall i.\, i\ \mathtt{free\_in}\ x \Longrightarrow f\ i = i)
  \end{equation*}
\item \textbf{Question:} Can we turn the above theorem into a
  \emph{dB-monadic} definition of \emph{free reference}?
\end{enumerate}

\section{Modules over dB-monads}
\label{sec:modules}

As for monad we have an associated notion of module, there is a
parallel notion of \emph{dB-module over dB-monads}.

\subsection{Definition of dB-module}
\label{sec:definition-module}

\begin{definition}[Modules of a dB-monad]
  A \emph{dB-module} (or simply \emph{module}) of a dB-monad $\TT$ is
  a type $\MM$ with an \emph{action}
  \begin{equation*}
    \msubst\colon (\NN\to \TT) \to \MM \to \MM
  \end{equation*}
  satisfying the laws
  \begin{align*}
    \msubst(\refe,x) &= x\\
    \msubst(f,\msubst(g,x)) &= \msubst((\subst f \circ g), x)
  \end{align*}
  for all $x\in \MM$ and $f,g\colon \NN \to \TT$.
\end{definition}

\subsection{Examples of modules}
\label{sec:examples-modules}

\paragraph{The trivial module}

Every dB-monad is a module over itself in an obvious way.

\paragraph{Modules associated to modules of a monad}

Let $R$ be a monad over $\mathsf{Set}$.  Given a module $M$ over $R$,
$M(\NN)$ has a natural structure of module over the dB-monad $R(\NN)$.

\paragraph{Arbitrary products of modules}

Let $\TT$ be a dB-monad.  Arbitrary products of modules over $\TT$
are, in an obvious way, modules over $\TT$.

\section{Derived module}
\label{sec:derived-module}

Let $\MM$ be a module over the dB-monad $\TT$.

\begin{definition}[Derived dB-module]
  The \emph{derived dB-module} $\MM'$ of $\MM$ is a dB-module over
  $\TT$ given by the following structure:
  \begin{itemize}
  \item the carrier of $\MM'$ is the same as that of $\MM$,
  \item the action $\msubst'$ of $\MM'$ is defined by
    \begin{equation*}
    \msubst'(f,x) \stackrel{\mathsf{def}}{=} \msubst(f',x)
  \end{equation*}
  where $f'$ is defined by the equations:
  \begin{align*}
    f'(0) &= \refe(0)\\
    f'(i+1) &= \reindex(\mathtt{suc},f(i))
  \end{align*}
  and $\mathsf{suc} \colon \NN \to \NN$ denotes the \emph{successor
    function} ($\mathtt{suc}(i) = i+1$).
  \end{itemize}
\end{definition}

The necessary verification to establish that $\MM'$ is indeed a module
are easy.

\end{document}

%  LocalWords: unital associativity monad monoid functor
