\documentclass[a4paper,twoside,12pt]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsthm,amsmath,amssymb}
\usepackage{xypic}
\usepackage{natbib}

\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\theoremstyle{remark}
\newtheorem{remark}{Remark}
\theoremstyle{example}
\newtheorem{example}{Example}

\DeclareMathOperator{\Ob}{Ob}

\newcommand{\NN}{\mathbb{N}}
\newcommand{\TT}{\mathtt{T}}
\newcommand{\MM}{\mathtt{M}}
\newcommand{\subst}{\mathtt{subst}}
\newcommand{\refe}{\mathtt{ref}}
\newcommand{\frees}{\mathtt{frees}}
\newcommand{\reindex}{\mathtt{reindex}}
\newcommand{\msubst}{\mathtt{msubst}}

\title{A high-level perspective on de Bruijn encoding}
\author{Andr\'e Hirschowitz \and Marco Maggesi}
\date{April 2017}

\begin{document}
\maketitle

\begin{abstract}
  % We focus on a special class of (relative) monads which arise
  % naturally in the implementation of higher-order syntax with the de
  % Bruijn encoding.  We develop the algebraic theory of such \emph{de
  %   Bruijn monads} (\emph{dB-monads}) and we show how they can be used
  % to easily extrapolate several useful \emph{fusion laws} which
  % otherwise might be tricky to devise.  Finally we develop a theory of
  % initial semantics for algebraic syntax in this framework.

  We propose an explanation for the success of the deBruijn encoding
  of the syntax associated to a (higher-order) signature $\Sigma$.
  Indeed, we show how it can be viewed as the initial representation
  of $\Sigma$ in relative monads (in the sense of Altenkirch, Chapman,
  and Uustalu) on a very simple functor.  This functor is the
  embedding into the category $\mathsf{Set}$ of its full subcategory
  with one object $\NN$.  This high-level point of view allows us to
  easily extrapolate several useful "fusion laws" which otherwise
  might be tricky to devise.
\end{abstract}

\tableofcontents{}

\section{Introduction}
\label{sec:intro}

De Bruijn encoding is a popular programming technique for implementing
higher-order calculi.  In these notes, we seek for a concise and clear
theoretic formulation of this method with the help of the categorical
point of view.

To be done.
Advantages:
\begin{itemize}
\item Help to reason about de Bruijn encoding: write \emph{fusion
    laws} without pain.
\item Simple: just three easy axioms, category-theoretic in nature,
  but Category Theory not strictly required.
\item Basic: can be formalized idiomatically in HOL, no dependent
  types required.
\end{itemize}

\subsection{The classical implementation of de Bruijn encoding}
\label{sec:classical-de-bruijn}

As a reference for the rest of the paper, we report here an
implementation in OCaml of $\lambda$-calculus using the de Bruijn
encoding.  With inessential modifications, the same code can be found
from several sources.  For instance, apart from certain superficial
syntactic changes, this is the implementation shown in Huet's notes on
\emph{Constructive Computation Theory} \cite[Section 1.4.2,
p.~15]{Huet-1992}.  In Section \ref{sec:lambda-calculus} we will
discuss an alternative implementation that come as a natural
consequence of the `monadic' approach.

We start by defining a new algebraic datatype \texttt{term} for
$\lambda$-terms:
\begin{verbatim}
type term = Ref of int | Abs of term | App of term * term;;
\end{verbatim}
Next, we define a \emph{lift} function, which will be responsible for
`bumping' free references during substitution.  The recursive
definition needs an auxiliary function, \texttt{lifti}, that takes an
additional parameter $k$ for counting the number of abstraction that
has been traversed.
\begin{verbatim}
let rec lifti n t k =
  match t with
    Ref i     -> if i < k then Ref i
                 else Ref (n + i)
  | App (t,u) -> App (lifti n t k, lifti n u k)
  | Abs t     -> Abs (lifti n t (k + 1));;

let lift n t = lifti n t 0;;
\end{verbatim}
Then, we define the substitution function $\mathtt{subst1}\ u t$ which
replace the term $u$ for the $0$-th reference in the term $t$.  Here
the suffix \texttt{1} in the name of the function is meant to remember
us that only this is the \emph{one-reference} substitution (in
contrast with the \emph{parallel substitution} that we will use
later).
\begin{verbatim}
let rec substi n w = function
    Ref k     -> if k=n then lift n w
                 else if k<n then Ref k
                 else Ref (pred k)
  | App (t,u) -> App (substi n w t, substi n w u)
  | Abs t     -> Abs (substi (n+1) w t);;

let subst1 = substi 0;;
\end{verbatim}
Again, the actual work is done by an auxiliary function
\texttt{substi} which has an additional parameter $k$ for
the \emph{abstraction depth}.

One key point of these notes is to describe how the functional
paradigm allows us to keep track of the abstraction depth in a more
elegant and clear way and to show that this lead to an alternative
programming practice which is seamlessly integrated with the
categorical treatment of higher-order syntax.

\section{Basic definitions and examples}
\label{sec:basic-def}

\subsection{Definition of dB-monad}
\label{sec:basic-defin-example}

\begin{definition}[dB-monad]
  A \emph{dB-monad} is given by a type $\TT$ and two functions
  \begin{align*}
    \refe &\colon \NN \to \TT, \\
    \subst &\colon (\NN \to \TT) \to \TT \to \TT
  \end{align*}
  called \emph{reference} and \emph{substitution}, satisfying the
  following three conditions\footnote{For function application we
    follow the convention of implicit currying as in the HoTT Book,
    e.g., $f(x,y) = f(x)(y) = (f(x))(y)$.}
  \begin{align*}
    \subst(f,\refe(i)) &=  f(i)
    && \text{right unital law} \\
    \subst(\refe, x) &=  x
    && \text{left unital law} \\
    \subst(f, \subst(g, x)) &= \subst(\subst(f) \circ g, x)
    &&\text{associativity law}
  \end{align*}
  for all $x : \TT$, $i :\NN$ and $f,g\colon \NN \to \TT$.
\end{definition}

We will simply call $\TT$ the dB-monad
$\langle \TT, \refe, \subst \rangle$ whenever no confusion can arise.
The type $\TT$ itself will be referred as the \emph{carrier} of the
dB-monad.

\subsection{Examples of dB-monads}
\label{sec:examples-dB-monads}

We now consider some basic examples of dB-monads.

\begin{example}[The initial dB-monad]
  The type $\NN$ of natural numbers has a trivial structure of
  dB-monad with $\refe(i) \stackrel{\mathsf{def}}{=} i$ and
  $\subst(f,i) \stackrel{\mathsf{def}}{=} f(i)$.
\end{example}

\begin{example}[The dB-monad of lists]
  A less trivial example is the \emph{dB-monad of lists} (which might
  well also called \emph{free monoid dB-monad}) defined as follows:
  \begin{align*}
    T &\stackrel{\mathsf{def}}{=}\mathtt{list}(\NN) \\
    \refe(i) &\stackrel{\mathsf{def}}{=} [i] \\
    \subst(f,[x_1, \dots, x_n] &\stackrel{\mathsf{def}}{=} f(x_1) + \cdots + f(x_n)
  \end{align*}
  where $[i]$ denotes the singleton lists and `$+$' in the last
  identity denotes the concatenation of lists.
\end{example}

\begin{example}[The dB-monad associated to a monad]
  \label{ex:list-db-monad}
  Given a monad $M$ on $\mathsf{Set}$ (the category of small sets),
  $\TT \stackrel{\mathsf{def}}{=} M(\NN)$ has a natural structure of
  dB-monad where $\refe = \eta_\NN$ and
  $\subst(f) \stackrel{\mathsf{def}}{=} \mathsf{bind}(f)$.
\end{example}

Indeed, our previous Example \ref{ex:list-db-monad} about the dB-monad
of lists is precisely the dB-monad associated to the monad of lists.

\begin{example}[TODO: The dB-monad associated to a relative monad(?)]
  Generalization of the previous example.

  dB-monads are relative monad on
  $J\colon \langle \NN \rangle \to \mathsf{Set}$.

  Can we consider other kind of functors for $J$?

  Of course (see previous paragraph ``The dB-monad associated to a
  monad'') we can take take the identity
  $J:\mathsf{Set} \to \mathsf{Set}$.

  More generally, I suspect that anything with target into
  $\mathsf{Set}$ should work.  Is that the case?
\end{example}

\begin{example}[TODO: (relative?) monad associated to a dB-monad]
  [Left Kan extension sould provide us with everything we need.]
\end{example}

\begin{example}[dB-monad of $\lambda$-calculus]
  For now, we simply introduce the dB-monad $\mathsf{\Lambda}$ of
  (syntactic) $\lambda$-calculus as the one associated to the
  corresponding monad $\Lambda$, as stated before.  Later we will
  discuss a more explicit construction of $\mathtt{\Lambda}$.
\end{example}

\subsection{dB-monads and relative monads}
\label{sec:subst-rel-monads}

\begin{definition}[Relative monad]
  A \emph{relative monad} over a functor
  $J\colon \mathsf{J}\to \mathsf{C}$ is given by
  \begin{itemize}
  \item a mapping $M:\Ob \mathsf{J} \to \mathsf{C}$;
  \item for every object $X$ of $\mathsf{J}$, an arrow $\eta_X\colon
    J(X) \to M(X)$;
  \item for every pair of objects $X,Y$ of $\mathsf{J}$, and for every
    arrow $f\colon J(X) \to M(Y)$, a \emph{Kleisli extension}
    $\sigma(f) \colon M(X) \to M(Y)$
  \end{itemize}
  satisfying the identities
  \begin{align*}
    \sigma(f) \circ \eta &= f &&\text{right unital law} \\
    \sigma(\eta_X) &= \mathsf{id}_{M(X)} &&\text{left unital law} \\
    \sigma(f) \circ \sigma(g) &= \sigma(\sigma(f) \circ g) &&\text{associativity law}
  \end{align*}
  for all objects $X,Y,Z$ of $\mathsf{J}$ and forall arrows
  $f\colon J(Y)\to M(Z)$, $g\colon J(X)\to M(Y)$.
\end{definition}

We are going to show how a dB-monad $\TT$ has a natural structure of
relative monad.  Take
$\mathsf{J} \stackrel{\mathsf{def}}{=}\langle \NN \rangle$ (the full
subcategory of $\mathsf{Set}$ generated by $\NN$).  We call \emph{de
  Bruijn functor} (or \emph{dB-functor}) the inclusion
\begin{equation}
  \label{eq:dB-functor}
  \mathsf{dB}\colon \langle \NN \rangle \to \mathsf{Set}.
\end{equation}

Then, it can be observed that dB-monads correspond precisely to monads
relative to the de Bruijn functor.  More precisely, given a dB-monad
$\TT$, define
\begin{align*}
  M(\NN) &\stackrel{\mathsf{def}}{=} \TT, \\
  \eta_\NN &\stackrel{\mathsf{def}}{=} \refe, \\
  \sigma &\stackrel{\mathsf{def}}{=} \subst.
\end{align*}
Then $M,\eta,\sigma$ is a relative monad over $J$.

% \subsection{dB-monads and relative monads -- alternative version(?)}
% \label{sec:subst-rel-monads-alt}

% Alternative(?) construction of the relative monad associated to a
% dB-monad.

% [The construction in the previous section has at least one advantage
% with respect to the one presented here, namely, the functor $J$ is
% independent from the particular dB-monad.  This section will be
% deleted in the future, but for now, let's keep record of this
% alternative construction.]

% \begin{itemize}
% \item $\mathsf{J}\stackrel{\mathsf{def}}{=}*$ the final category
%   (i.e., the category with just one object and one arrow),
% \item $\mathsf{C}\stackrel{\mathsf{def}}{=}\langle\NN\rangle$ the
%   monoid given by the maps $\NN\to\NN$ (in other words, the full
%   subcategory of $\mathsf{Set}$ generated by $\NN$);
% \item $J\colon \mathsf{J} \to \mathsf{C}$ the natural injection.
% \end{itemize}

% \begin{proposition}[Every dB-monad is relative monad over $J$]
%   Given a dB-monad $\TT$, define
%   \begin{align*}
%     M(*) &\stackrel{\mathsf{def}}{=} \TT, \\
%     \eta_* &\stackrel{\mathsf{def}}{=} \refe, \\
%     \sigma &\stackrel{\mathsf{def}}{=} \subst.
%   \end{align*}
%   Then $M,\eta,\sigma$ is a relative monad over $J$.
% \end{proposition}

\subsection{Functoriality of dB-monads}
\label{sec:further-operators-db}

Given a dB-monad $\TT$ we can define the \emph{reindex} operator
\begin{equation*}
  \reindex\colon (\NN \to \NN) \to (\TT \to \TT)
\end{equation*}
given by
\begin{equation*}
  \reindex(f,x) = \subst(\refe \circ f, x).
\end{equation*}
It is straightforward to verify, from the axioms of dB-monad, that the
following \emph{fusion} laws holds for $\reindex$:
\begin{align*}
  \reindex(f,\refe(i)) &= \refe(f(i)) \\
  \reindex(\refe,x) &= x \\
  \reindex(f,\subst(g,x)) &= \subst(\reindex(f) \circ g, x) \\
  \subst(f,\reindex(g,x)) &= \subst(f \circ g,x) \\
  \reindex(f,\reindex(g,x)) &= \reindex(f\circ g, x) \\
\end{align*}

\subsection{Morphisms of dB-monads}
\label{sec:morphisms-db-monads}

\begin{definition}[Morphisms of dB-monad]
  Given two dB-monads $\TT_1$, $\TT_2$ with substitutions $\subst_1$,
  $\subst_2$ and references $\refe_1$, $\refe_2$ a \emph{morphism} of
  dB-monads is a function $\phi\colon \TT_1 \to \TT_2$ such that
  satisfies the  identities
  \begin{align*}
    \phi(\refe_1(i)) &= \refe_2(i) \\
    \phi(\subst_1(f,x)) &= \subst_2(\phi \circ f, \phi(x))
  \end{align*}
  for all $i \in \NN$ and $f\colon \NN \to \TT_1$.
\end{definition}

It is immediate to verify that the previous definition builds
dB-monads into a category $\mathsf{dB}$ which is precisely, the
category of relative monads over the functor $J$ of
\eqref{eq:dB-functor}.

It follows at once that morphisms of dB-monads commute with
reindexing, that is, for all $\phi\colon \TT_1 \to \TT_2$,
$x\in \TT_1$ and $f\colon \NN\to \NN$ we have
\begin{equation*}
  \phi(\reindex_1(f,x)) = \reindex_2(f,\phi(x)) .
\end{equation*}

\subsection{Free references}
\label{sec:free-references}

The substitution operator determines the set $\frees(x)$ of \emph{free
  references} in a term $x$ of a dB-monad $\TT$.  The key property is
\begin{equation*}
  \subst(f,x) = x \Longleftrightarrow
  (\forall i.\, i \in \mathtt{frees}(x) \Longrightarrow f(i) = i).
\end{equation*}

A suitable definition of free references i the following.
\begin{definition}[Free references]
  The set of \emph{free references} $\frees(x)$ of a term $x$ in a
  dB-monad $\TT$ is the set of natural numbers
  \begin{equation*}
    \frees(x) \stackrel{def}{=}
    \Big\{
    i\ \Big|\  \forall f.\, (\forall j.\, j\neq i \Longrightarrow f(j) = \refe(j)) \wedge
    \subst(f,x) = x
    \Big\}
  \end{equation*}
\end{definition}

For reindexing we have property analogous to that of substitution:
\begin{equation*}
  \reindex(f,x) = x \Longleftrightarrow
  (\forall i.\, i \in \mathtt{frees}(x) \Longrightarrow f(i) = \refe(i)).
\end{equation*}
More generally, we have the following result of extensionality.
\begin{proposition}
  Let $x$ be a term of a dB-monad $\TT$.  Then
  \begin{enumerate}
  \item if two functions $f,g\colon \NN\to \TT$ agrees on $\frees(x)$
    then $\subst(f,x) = \subst(g,x)$;
  \item if two functions $f,g\colon \NN\to \NN$ agrees on $\frees(x)$
    then $\reindex(f,x) = \reindex(g,x)$.
  \end{enumerate}
\end{proposition}

\section{Modules over dB-monads}
\label{sec:modules}

As for monad we have an associated notion of module, there is a
parallel notion of \emph{dB-module over dB-monads}.

\subsection{Definition of dB-module}
\label{sec:definition-module}

\begin{definition}[Modules of a dB-monad]
  A \emph{dB-module} (or simply \emph{module}) of a dB-monad $\TT$ is
  a type $\MM$ with an \emph{action}
  \begin{equation*}
    \msubst\colon (\NN\to \TT) \to \MM \to \MM
  \end{equation*}
  satisfying the laws
  \begin{align*}
    \msubst(\refe,x) &= x\\
    \msubst(f,\msubst(g,x)) &= \msubst(\subst f \circ g, x)
  \end{align*}
  for all $x\in \MM$ and $f,g\colon \NN \to \TT$.
\end{definition}

\subsection{Examples of modules}
\label{sec:examples-modules}

\begin{example}[The tautological dB-module]
  Every dB-monad is a module over itself in an obvious way.
\end{example}

\begin{example}[Modules associated to modules of a monad]
  Let $R$ be a monad over $\mathsf{Set}$.  Given a module $M$ over
  $R$, $M(\NN)$ has a natural structure of module over the dB-monad
  $R(\NN)$.
\end{example}

\begin{example}[Products of modules]
  Let $\TT$ be a dB-monad.  Arbitrary products of modules over $\TT$
  are, in an obvious way, modules over $\TT$ (see also Proposition
  \ref{prop:modules-product}).
\end{example}

\subsection{Morphisms of dB-modules}
\label{sec:morphisms-db-modules}

In this section $\TT$ will be a fixed dB-monad.

\begin{definition}[Morphisms of dB-modules]
  Let $\MM_1$, $\MM_2$ two $\TT$-modules with actions $\msubst_1$ and
  $\msubst_2$.  A $\TT$-\emph{linear morphism} (or \emph{morphism of
    $\TT$-modules} is a map $\phi\colon \MM_1 \to \MM_2$ compatible
  with the module actions in the following sense:
  \begin{equation*}
    \phi(\msubst_1(f,x)) = \msubst_2(f,\phi(x)).
  \end{equation*}
\end{definition}

The family of modules over a fixed monad together with their morphisms
forms a category that we denote $\mathsf{Mod}(\TT)$.

\begin{proposition}
  \label{prop:modules-product}
  The category $\mathsf{Mod}(\TT)$ has arbitrary products.
\end{proposition}

\subsection{Derived module}
\label{sec:derived-module}

Let $\MM$ be a module over the dB-monad $\TT$.

\begin{definition}[Derived dB-module]
  The \emph{derived dB-module} $\MM'$ of $\MM$ is a dB-module over
  $\TT$ given by the following structure:
  \begin{itemize}
  \item the carrier of $\MM'$ is the same as that of $\MM$,
  \item the action $\msubst'$ of $\MM'$ is defined by
    \begin{equation*}
    \msubst'(f,x) \stackrel{\mathsf{def}}{=} \msubst(f',x)
  \end{equation*}
  where $f'$ is defined by the equations:
  \begin{align*}
    f'(0) &= \refe(0)\\
    f'(i+1) &= \reindex(\mathtt{suc},f(i))
  \end{align*}
  and $\mathsf{suc} \colon \NN \to \NN$ denotes the \emph{successor
    function} ($\mathtt{suc}(i) = i+1$).
  \end{itemize}
\end{definition}

The necessary verification to establish that $\MM'$ is indeed a module
are easy.  A refined statement is given by the following proposition.

\begin{proposition}(Derivation as endofunctor)
  \label{prop:derivation-endo}
  Derivation yields a Cartesian endofunctor of $\mathsf{Mod}(\TT)$.
\end{proposition}

\subsection{Pull-backs}
\label{sec:pull-backs}

\begin{definition}[Pull-back of a dB-module]
  Given a morphism of dB-module $\phi\colon \TT_1 \to \TT_2$ and a
  $\TT_2$ module $\MM$ with action $\msubst_2$ we can define a
  structure of $\TT_1$-module on $\MM$ given by the action
  \begin{equation*}
    \msubst_1(f,x) \stackrel{\mathsf{def}}{=} \msubst_2(\phi \circ f, x).
  \end{equation*}
  We will write $\phi^*(\MM)$ to denote the pull-back of $\MM$ along
  $\phi$.
\end{definition}

Given $\phi\colon \TT_1 \to \TT_2$ as in the definition every $\TT_2$
linear morphism $\psi\colon \MM_1 \to \MM_2$ is also a $\TT_2$-linear
morphism.  More precisely the following proposition holds.

\begin{proposition}
  \label{prop:pull-back-functor}
  The pull-back
  $\phi^* \colon \mathsf{Mod}(\TT_2) \to \mathsf{Mod}(\TT_1)$ is
  cartesian functor.
\end{proposition}

\section{$\lambda$-calculus}
\label{sec:lambda-calculus}

\subsection{The dB-monad of $\lambda$-calculus}
\label{sec:db-monad-lambda}

TODO.
[Say that abs and app are linear.]

\subsection{La supériorité de l'ordre supérieur}
\label{sec:super}

We now expose the construction of the dB-monad of $\lambda$-calculus
in OCaml.  Lambda terms are represented with the same datatype an in
Section \ref{sec:classical-de-bruijn}:
\begin{verbatim}
type term = Ref of int | Abs of term | App of term * term;;
\end{verbatim}

Since OCaml do not allows to pass constructors as function arguments,
we provide the following additional definition:
\begin{verbatim}
let idenv i     = Ref i;;
\end{verbatim}
The name \texttt{idenv} is mnemonic for \emph{identity environment}
which comes from the fact that a function $\NN \to \mathtt{term}$ can
be seen as an environment for terms.

Then, we can give the main definition:
\begin{verbatim}
let rec subst f = function Ref i    -> f i
                         | App(t,u) -> App(subst f t,subst f u)
                         | Abs t    -> Abs(diff subst f t)
and reindex f x = subst (idenv o f) x
and diff s f t  = s (push (Ref 0) f) t
and bump t      = reindex succ t
and push u f    = function 0 -> u
                         | i -> bump (f(i-1));;
\end{verbatim}

Finally, the single substitution can be easily derived from parallel substitution.
\begin{verbatim}
let subst1 u t  = subst (push u idenv) t;;
\end{verbatim}

\section{Initial semantics with dB-monads}
\label{sec:init-semantics}

\subsection{Signatures and representations in dB-modules}
\label{sec:signatures-representations}

\begin{definition}[Arities and representations of arities]
  \hfill
  \begin{itemize}
  \item An \emph{arity} is a finite list of non-negative integer.
  \item Given a dB-monad $\TT$, a $\TT$-module $\MM$ and an arity
    $a=(a_1,\dots,a_n)$, a \emph{representation of the arity $a$ in
      $\MM$} is a $\TT$-linear morphism
    \begin{equation*}
      \phi:\MM^{(a_1)}\times\cdots\times\MM^{(a_n)} \longrightarrow \MM
    \end{equation*}
  \item A \emph{signature} is a family of arities.
  \item A \emph{representation of a signature} $\Sigma$ is given by a
    representation for each of its arities.
  \end{itemize}
\end{definition}

In the sequel, we will abbreviate
$\MM^{(a_1)}\times\cdots\times\MM^{(a_n)}$ with $M^{a_1,\dots,a_n}$ or
by $\MM^a$.

In particular, we can consider representation of a signature in a
dB-monad, by taking the associated tautological module.  We form a
category of representation in a dB-monad.

\begin{definition}[The category of representation in a dB-monad]
  Let $\phi \colon \TT_1 \to \TT_2$ be a morphism between two
  dB-monads, each of which endowed by a representation of a signature
  $\Sigma$.  We say that $\phi$ is a \emph{morphism of
    $\Sigma$-representations} if, for each arity $a$ of $\Sigma$, the
  induced diagram diagram
  \begin{equation*}
    \xymatrix{
      \TT_1^a\ar[d]\ar[r] & \TT_1\ar[d]^\phi \\
      \TT_2^a \ar[r] & \TT_2}
  \end{equation*}
  where the orizontal arrows are the representations of $a$.
\end{definition}

\bibliographystyle{plainnat}
%\bibliographystyle{alpha}
\bibliography{dbmonad}
\end{document}

%  LocalWords: unital associativity monad monoid functor monads arity
%  LocalWords: arities morphism morphisms monadic reindexing
%  LocalWords: extensionality
